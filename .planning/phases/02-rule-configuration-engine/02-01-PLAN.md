---
phase: 02-rule-configuration-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/templates/factsheet.yaml
  - backend/templates/brief.yaml
  - backend/templates/publication.yaml
  - backend/app/config/__init__.py
  - backend/app/config/models.py
autonomous: true

must_haves:
  truths:
    - "Rule templates load successfully for all 3 base configurations"
    - "Invalid rule templates are rejected with clear error messages"
    - "Templates contain rules grouped by category (Cover, Margins, Typography, Images, Required Elements)"
  artifacts:
    - path: "backend/templates/factsheet.yaml"
      provides: "Factsheet rule defaults"
      contains: "document_type: factsheet"
    - path: "backend/templates/brief.yaml"
      provides: "Policy Brief and Issue Note rule defaults"
      contains: "document_type: brief"
    - path: "backend/templates/publication.yaml"
      provides: "Working Paper and Publication rule defaults"
      contains: "document_type: publication"
    - path: "backend/app/config/models.py"
      provides: "Pydantic models for rule validation"
      exports: ["Rule", "RuleOverride", "Category", "Template"]
  key_links:
    - from: "backend/app/config/models.py"
      to: "templates/*.yaml"
      via: "Template.parse_obj on yaml.safe_load"
      pattern: "yaml\\.safe_load"
---

<objective>
Create YAML rule templates and Pydantic validation models for UNEP design compliance rules.

Purpose: Establish the data foundation for the rule configuration engine. The 3 YAML templates define default rules for 5 document types, while Pydantic models ensure type-safe loading and validation.

Output: 3 YAML template files with comprehensive UNEP design rules, plus Pydantic models for Rule, Category, Template, and RuleOverride.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rule-configuration-engine/02-CONTEXT.md
@.planning/phases/02-rule-configuration-engine/02-RESEARCH.md

# Source material for rules
@Rules/Factsheet_Design_Rules.md
@Rules/Policy_Brief_Working_Paper_Guidelines.md
@Rules/A4_Main_Publication_Guidelines.md

# Existing Pydantic patterns
@backend/app/models/extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models for rule configuration</name>
  <files>
    backend/app/config/__init__.py
    backend/app/config/models.py
  </files>
  <action>
Create the config module with Pydantic v1 models for rule configuration.

In `backend/app/config/__init__.py`:
- Export all models from models.py

In `backend/app/config/models.py`:
- Create `RuleExpected` model with `class Config: extra = "allow"` to handle different check types
- Create `Rule` model with fields:
  - `name: str` - Human-readable rule name
  - `description: str` - What this rule checks
  - `enabled: bool = True`
  - `severity: Literal["error", "warning"] = "error"`
  - `check_type: str` - One of: position, range, font, regex, presence, color
  - `expected: RuleExpected` - Type-specific expected values
- Create `RuleOverride` model with all fields Optional (for user customizations)
- Create `Category` model with `name: str` and `rules: Dict[str, Rule]`
- Create `Template` model with `version: str`, `document_type: str`, `categories: Dict[str, Category]`
- Create `UserOverrides` model with `version: str` and `overrides: Dict[str, Dict[str, RuleOverride]]` (category -> rule_id -> override)

Follow existing Pydantic v1 patterns from extraction.py (use `class Config` not `model_config`).
  </action>
  <verify>
python -c "from app.config.models import Rule, Category, Template, RuleOverride, UserOverrides; print('Models import OK')"
  </verify>
  <done>All Pydantic models import without error and follow v1 patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create YAML rule templates</name>
  <files>
    backend/templates/factsheet.yaml
    backend/templates/brief.yaml
    backend/templates/publication.yaml
  </files>
  <action>
Create 3 YAML templates with rules derived from the Rules/*.md guidelines. Each template has this structure:

```yaml
version: "1.0"
document_type: "{type}"  # factsheet, brief, or publication
categories:
  cover:
    name: "Cover"
    rules:
      unep_logo_position:
        name: "UNEP logo position"
        description: "Logo must be in top-right corner"
        enabled: true
        severity: "error"
        check_type: "position"
        expected:
          position: "top-right"
          min_size_mm: 20
          target_size_mm: 27.5
```

**factsheet.yaml** - For Factsheet documents:
- Cover: logo position (27.5mm, top-right), title size (28-34pt), subtitle size (18-24pt)
- Margins: left/right (20-25mm), top/bottom (15-20mm)
- Typography: body text (11-12pt Roboto Flex), captions (9-10pt), chart axes (8pt Roboto Condensed)
- Images: min DPI (300 for print), color space (RGB or CMYK)
- Required Elements: (minimal for factsheets - no ISBN/DOI required)

**brief.yaml** - For Policy Brief and Issue Note:
- Cover: logo position, title size (28-34pt), partner logos
- Margins: similar to factsheet
- Typography: body (9-12pt), headings hierarchy
- Images: min DPI (300)
- Required Elements: DOI optional

**publication.yaml** - For Working Paper and Publication:
- Cover: logo position, title, subtitle
- Margins: top (20-25mm), bottom (20mm+), inside (20-30mm), outside (20-25mm)
- Typography: body (9-12pt Roboto Flex), H1-H4 hierarchy, captions (7pt)
- Images: min DPI (300), color space validation
- Required Elements: ISBN (for full publications), DOI, job number, disclaimer, copyright, SDG icons (1-3)

Quote all string values to avoid YAML type coercion issues (the "Norway problem").
  </action>
  <verify>
python -c "
import yaml
from pathlib import Path
from app.config.models import Template

for name in ['factsheet', 'brief', 'publication']:
    path = Path('templates') / f'{name}.yaml'
    with open(path) as f:
        data = yaml.safe_load(f)
    template = Template(**data)
    print(f'{name}: {len(template.categories)} categories, document_type={template.document_type}')
"
  </verify>
  <done>All 3 templates parse and validate successfully with Pydantic models</done>
</task>

</tasks>

<verification>
1. All 3 YAML templates exist in backend/templates/
2. Templates load without YAML parsing errors
3. Pydantic validation passes for all templates
4. Each template has 5 categories: cover, margins, typography, images, required_elements
5. Rule structure matches expected schema (name, description, enabled, severity, check_type, expected)
</verification>

<success_criteria>
- 3 YAML template files created with comprehensive UNEP rules
- Pydantic models validate template structure
- Templates cover all rule categories from CONTEXT.md
- No YAML type coercion issues (strings properly quoted)
</success_criteria>

<output>
After completion, create `.planning/phases/02-rule-configuration-engine/02-01-SUMMARY.md`
</output>
