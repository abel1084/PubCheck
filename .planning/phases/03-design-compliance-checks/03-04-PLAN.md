---
phase: 03-design-compliance-checks
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - frontend/src/types/checks.ts
  - frontend/src/hooks/useComplianceCheck.ts
  - frontend/src/components/CheckResults/CheckResults.tsx
  - frontend/src/components/CheckResults/CheckResults.css
  - frontend/src/components/CheckResults/CategorySection.tsx
  - frontend/src/components/CheckResults/IssueCard.tsx
  - frontend/src/components/CheckResults/StatusBadge.tsx
  - frontend/src/components/CheckResults/index.ts
  - frontend/src/components/DataTabs/DataTabs.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can click Check button and see compliance results"
    - "Results grouped by category with collapsible sections"
    - "Issues show severity (error/warning), message, expected vs actual, pages"
    - "Categories with errors expanded by default, others collapsed"
    - "Zero issues shows success banner with 'All checks passed'"
    - "Check button disabled until PDF uploaded"
  artifacts:
    - path: "frontend/src/types/checks.ts"
      provides: "TypeScript types for check results"
      exports: ["CheckIssue", "CategoryResult", "CheckResult"]
    - path: "frontend/src/hooks/useComplianceCheck.ts"
      provides: "Hook for running checks and managing state"
      exports: ["useComplianceCheck"]
    - path: "frontend/src/components/CheckResults/CheckResults.tsx"
      provides: "Main check results component"
      exports: ["CheckResults"]
  key_links:
    - from: "frontend/src/hooks/useComplianceCheck.ts"
      to: "/api/check/{document_type}"
      via: "POST fetch call"
      pattern: "fetch.*api/check"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/CheckResults/CheckResults.tsx"
      via: "renders CheckResults in results view"
      pattern: "<CheckResults"
---

<objective>
Build the frontend Check Results UI: TypeScript types matching backend models, useComplianceCheck hook for API integration, and collapsible results display with category sections, issue cards, and status badge.

Purpose: Completes the user-facing experience where users can run compliance checks and review categorized findings.
Output: frontend/src/types/checks.ts, frontend/src/hooks/useComplianceCheck.ts, frontend/src/components/CheckResults/
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/LEARNINGS.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-design-compliance-checks/03-CONTEXT.md
@.planning/phases/03-design-compliance-checks/03-RESEARCH.md
@.planning/phases/03-design-compliance-checks/03-01-SUMMARY.md
@.planning/phases/03-design-compliance-checks/03-02-SUMMARY.md
@.planning/phases/03-design-compliance-checks/03-03-SUMMARY.md

@frontend/src/App.tsx
@frontend/src/App.css
@frontend/src/components/DataTabs/DataTabs.tsx
@frontend/src/components/Settings/Settings.tsx
@frontend/src/types/extraction.ts
@backend/app/checks/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types and useComplianceCheck hook</name>
  <files>frontend/src/types/checks.ts, frontend/src/hooks/useComplianceCheck.ts</files>
  <action>
1. Create `frontend/src/types/checks.ts` matching backend models:

```typescript
export interface CheckIssue {
  rule_id: string;
  rule_name: string;
  severity: 'error' | 'warning';
  message: string;
  expected: string | null;
  actual: string | null;
  pages: number[];
  how_to_fix?: string;
}

export interface CategoryResult {
  category_id: string;
  category_name: string;
  issues: CheckIssue[];
  error_count: number;
  warning_count: number;
}

export interface CheckResult {
  document_type: string;
  categories: CategoryResult[];
  total_errors: number;
  total_warnings: number;
  status: 'pass' | 'fail' | 'warning';
  check_duration_ms: number;
}
```

2. Create `frontend/src/hooks/useComplianceCheck.ts`:

```typescript
import { useState, useCallback } from 'react';
import type { ExtractionResult } from '../types/extraction';
import type { CheckResult } from '../types/checks';

interface UseComplianceCheckResult {
  isChecking: boolean;
  checkResult: CheckResult | null;
  checkError: string | null;
  runCheck: (documentType: string, extraction: ExtractionResult) => Promise<void>;
  clearResult: () => void;
}

export function useComplianceCheck(): UseComplianceCheckResult {
  const [isChecking, setIsChecking] = useState(false);
  const [checkResult, setCheckResult] = useState<CheckResult | null>(null);
  const [checkError, setCheckError] = useState<string | null>(null);

  const runCheck = useCallback(async (
    documentType: string,
    extraction: ExtractionResult
  ) => {
    setIsChecking(true);
    setCheckError(null);

    try {
      const response = await fetch(`/api/check/${documentType}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(extraction),
      });

      if (!response.ok) {
        throw new Error(`Check failed: ${response.statusText}`);
      }

      const result: CheckResult = await response.json();
      setCheckResult(result);
    } catch (error) {
      setCheckError(error instanceof Error ? error.message : 'Check failed');
    } finally {
      setIsChecking(false);
    }
  }, []);

  const clearResult = useCallback(() => {
    setCheckResult(null);
    setCheckError(null);
  }, []);

  return { isChecking, checkResult, checkError, runCheck, clearResult };
}
```
  </action>
  <verify>npx tsc --noEmit src/types/checks.ts src/hooks/useComplianceCheck.ts 2>&1 | head -5 || echo "TypeScript check (may show import warnings - OK if types compile)"</verify>
  <done>TypeScript types match backend models; useComplianceCheck hook handles API calls with loading/error states</done>
</task>

<task type="auto">
  <name>Task 2: Create CheckResults component with category sections</name>
  <files>frontend/src/components/CheckResults/CheckResults.tsx, frontend/src/components/CheckResults/CheckResults.css, frontend/src/components/CheckResults/CategorySection.tsx, frontend/src/components/CheckResults/IssueCard.tsx, frontend/src/components/CheckResults/StatusBadge.tsx, frontend/src/components/CheckResults/index.ts</files>
  <action>
Create frontend/src/components/CheckResults/ module following BEM CSS patterns from existing components:

1. Create `index.ts` exporting CheckResults

2. Create `StatusBadge.tsx`:
- Pass: Green badge with checkmark
- Fail: Red badge with X
- Warning: Yellow/amber badge with warning icon

3. Create `IssueCard.tsx`:
- Show severity icon (red circle for error, yellow triangle for warning)
- Message as primary text
- Expected vs Actual values in compact format per CONTEXT.md: "150 DPI (min 300)"
- Page numbers: "Page 1" or "Pages 1, 3, 5" for multi-page issues
- Optional "How to fix" hint if provided
- Use details/summary for expandable card per Phase 2 pattern

4. Create `CategorySection.tsx`:
- Use native `<details>/<summary>` for collapse per established pattern
- Category name with count badge: "Typography (4)" or "Typography" with checkmark if no issues
- `defaultOpen={category.error_count > 0}` per CONTEXT.md
- Sort issues within: errors first, then warnings
- Show "No issues" message for empty categories

5. Create `CheckResults.tsx`:
- Header with StatusBadge, summary counts, Re-check button
- If status === 'pass': Large green success banner "All checks passed"
- Else: List of CategorySection components in fixed order
- Fixed category order: cover -> margins -> typography -> images -> required_elements

6. Create `CheckResults.css` with BEM naming:
- `.check-results`, `.check-results__header`, `.check-results__summary`
- `.category-section`, `.category-section__header`, `.category-section__content`
- `.issue-card`, `.issue-card__severity`, `.issue-card__message`
- `.status-badge`, `.status-badge--pass`, `.status-badge--fail`, `.status-badge--warning`
- Red for errors (#dc3545), yellow/amber for warnings (#ffc107)
- Green for pass/success (#28a745)
  </action>
  <verify>ls frontend/src/components/CheckResults/ && cat frontend/src/components/CheckResults/index.ts</verify>
  <done>CheckResults component renders categorized issues with collapsible sections, severity colors, and status badge</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Check button and results into App</name>
  <files>frontend/src/App.tsx, frontend/src/App.css, frontend/src/components/DataTabs/DataTabs.tsx</files>
  <action>
Integrate check functionality into the application:

1. Update `App.tsx`:
- Import useComplianceCheck hook
- Import CheckResults component
- Add Check button in header (next to Settings button) when result exists
- Check button disabled until PDF uploaded (result exists)
- Check button disabled while checking (with loading state)
- Show tooltip "Upload a PDF first" when disabled
- On Check click: Call runCheck with documentType and extraction
- Add "Check Results" tab to DataTabs when checkResult exists

2. Update `DataTabs.tsx`:
- Add optional `checkResult` prop (type: CheckResult | null) and `isChecking` prop (boolean)
- Add "Check Results" as new tab option (only visible when checkResult exists or isChecking)
- Component instantiation pattern:
  ```tsx
  // In DataTabs component
  {activeTab === 'check-results' && (
    isChecking
      ? <div className="data-tabs__loading"><Spinner /> Checking...</div>
      : checkResult && <CheckResults result={checkResult} />
  )}
  ```
- DataTabs receives checkResult prop from App.tsx and renders `<CheckResults result={checkResult} />` when Check Results tab is selected
- When checking, show spinner with "Checking..." text instead of CheckResults

3. Update `App.css`:
- Style Check button in header
- Add loading spinner styles for checking state
- Ensure header buttons (Check, Settings) are visually grouped

Per CONTEXT.md:
- "Check button lives in header/toolbar area"
- "Checks require explicit click (no auto-run after upload)"
- "Check button disabled with tooltip until PDF uploaded"
- "Results appear in new 'Check Results' tab alongside existing data tabs"
  </action>
  <verify>npm run build 2>&1 | tail -10 || echo "Build check"</verify>
  <done>Check button in header triggers compliance check; results appear in new Check Results tab; loading state shown during check</done>
</task>

</tasks>

<verification>
Frontend integration test:
```bash
cd frontend
npm run build 2>&1 | tail -20
```

Visual verification checklist (for user testing):
1. Upload a PDF - Check button becomes enabled
2. Click Check - Loading spinner appears
3. Results appear in new "Check Results" tab
4. Categories with errors are expanded by default
5. Click category header to collapse/expand
6. Issues show severity icon, message, expected vs actual
7. Multi-page issues show page list
8. Zero issues shows green success banner
</verification>

<success_criteria>
1. TypeScript types compile without errors
2. useComplianceCheck hook manages API state correctly
3. CheckResults displays categorized issues with collapsible sections
4. StatusBadge shows pass/fail/warning correctly
5. IssueCard shows severity, message, expected/actual, pages
6. Check button in header, disabled until PDF uploaded
7. Results appear in Check Results tab
8. BEM CSS naming consistent with existing components
</success_criteria>

<output>
After completion, create `.planning/phases/03-design-compliance-checks/03-04-SUMMARY.md`
</output>
