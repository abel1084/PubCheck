---
phase: 03-design-compliance-checks
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/checks/router.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/check/{document_type} accepts extraction data and returns check results"
    - "Results grouped by category in fixed order: cover, margins, typography, images, required_elements"
    - "Overall status computed: pass (no errors), fail (has errors), warning (warnings only)"
    - "Check duration measured and returned in response"
  artifacts:
    - path: "backend/app/checks/router.py"
      provides: "Check API endpoint"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "Main app with check router mounted"
      contains: "check_router"
  key_links:
    - from: "backend/app/checks/router.py"
      to: "backend/app/checks/executor.py"
      via: "uses create_executor() to run checks"
      pattern: "from .executor import create_executor"
    - from: "backend/app/checks/router.py"
      to: "backend/app/config/service.py"
      via: "loads merged rules for document type"
      pattern: "RuleService"
    - from: "backend/app/main.py"
      to: "backend/app/checks/router.py"
      via: "includes router"
      pattern: "include_router.*check"
---

<objective>
Create the REST API endpoint for running compliance checks. POST /api/check/{document_type} accepts extraction data, loads document type rules, executes all enabled checks, and returns categorized results with overall status.

Purpose: Bridges frontend to check execution, providing the API contract that the Check Results UI will consume.
Output: backend/app/checks/router.py with POST endpoint, updated main.py with router
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/LEARNINGS.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-design-compliance-checks/03-CONTEXT.md
@.planning/phases/03-design-compliance-checks/03-RESEARCH.md
@.planning/phases/03-design-compliance-checks/03-01-SUMMARY.md

@backend/app/main.py
@backend/app/config/router.py
@backend/app/config/service.py
@backend/app/checks/models.py
@backend/app/checks/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check API router</name>
  <files>backend/app/checks/router.py</files>
  <action>
Create `backend/app/checks/router.py` with POST endpoint:

```python
from fastapi import APIRouter, HTTPException
from typing import Literal
import time

from app.config.service import RuleService, DocumentTypeId
from app.models.extraction import ExtractionResult
from .executor import create_executor
from .models import CheckResult, CategoryResult

router = APIRouter(prefix="/api/check", tags=["check"])

# Singleton instances
_executor = create_executor()
_rule_service = RuleService()

# Fixed category order per CONTEXT.md
CATEGORY_ORDER = ['cover', 'margins', 'typography', 'images', 'required_elements']

@router.post("/{document_type}", response_model=CheckResult)
async def run_checks(
    document_type: DocumentTypeId,
    extraction: ExtractionResult,
) -> CheckResult:
    """Run compliance checks on extracted PDF data."""
    start_time = time.time()

    # Load merged rules for document type
    try:
        template = _rule_service.get_merged_rules(document_type)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Unknown document type: {document_type}")

    # Execute checks by category
    category_results = []
    total_errors = 0
    total_warnings = 0

    for cat_id in CATEGORY_ORDER:
        if cat_id not in template.categories:
            # Include empty category for completeness
            category_results.append(CategoryResult(
                category_id=cat_id,
                category_name=cat_id.replace('_', ' ').title(),
                issues=[],
                error_count=0,
                warning_count=0,
            ))
            continue

        category = template.categories[cat_id]
        category_issues = []

        for rule_id, rule in category.rules.items():
            issues = _executor.execute_rule(extraction, rule)
            # Add rule_id to each issue for reference
            for issue in issues:
                issue.rule_id = rule_id
            category_issues.extend(issues)

        error_count = sum(1 for i in category_issues if i.severity == "error")
        warning_count = sum(1 for i in category_issues if i.severity == "warning")

        category_results.append(CategoryResult(
            category_id=cat_id,
            category_name=category.name,
            issues=category_issues,
            error_count=error_count,
            warning_count=warning_count,
        ))

        total_errors += error_count
        total_warnings += warning_count

    # Determine overall status per CONTEXT.md
    if total_errors > 0:
        status = "fail"
    elif total_warnings > 0:
        status = "warning"
    else:
        status = "pass"

    duration_ms = int((time.time() - start_time) * 1000)

    return CheckResult(
        document_type=document_type,
        categories=category_results,
        total_errors=total_errors,
        total_warnings=total_warnings,
        status=status,
        check_duration_ms=duration_ms,
    )
```

Key behaviors:
- Fixed category order: Cover -> Margins -> Typography -> Images -> Required Elements
- All categories included even if empty (per CONTEXT.md: "Show all categories including empty ones")
- Status: pass (no errors), fail (has errors), warning (warnings only)
- Duration tracked in milliseconds
  </action>
  <verify>python -c "from app.checks.router import router; print(f'Router prefix: {router.prefix}, routes: {len(router.routes)}')"</verify>
  <done>router.py exports router with POST /api/check/{document_type} endpoint returning CheckResult</done>
</task>

<task type="auto">
  <name>Task 2: Register check router in main app</name>
  <files>backend/app/main.py</files>
  <action>
Update `backend/app/main.py` to include the check router:

1. Add import:
```python
from app.checks.router import router as check_router
```

2. Add router registration after existing routers:
```python
app.include_router(check_router)
```

Place after the config_router registration to maintain logical grouping.
  </action>
  <verify>curl -X POST http://localhost:8002/api/check/factsheet -H "Content-Type: application/json" -d '{"metadata":{"filename":"test.pdf","page_count":1},"text_blocks":[],"images":[],"margins":[],"fonts":[]}' 2>/dev/null | python -c "import sys,json; r=json.load(sys.stdin); print(f'Status: {r[\"status\"]}, Categories: {len(r[\"categories\"])}')" || echo "Server not running - verify imports work"</verify>
  <done>main.py includes check_router, POST /api/check/{document_type} accessible</done>
</task>

<task type="auto">
  <name>Task 3: Update checks __init__.py exports</name>
  <files>backend/app/checks/__init__.py</files>
  <action>
Update `backend/app/checks/__init__.py` to export router for clean imports:

```python
from .models import CheckIssue, CategoryResult, CheckResult
from .executor import CheckExecutor, create_executor
from .router import router

__all__ = [
    "CheckIssue",
    "CategoryResult",
    "CheckResult",
    "CheckExecutor",
    "create_executor",
    "router",
]
```
  </action>
  <verify>python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/api/check/{document_type}' in routes, f'Route not registered: {routes}'; print('Check route registered in main.py')"</verify>
  <done>__init__.py exports router and all models; router registered in main.py app.routes</done>
</task>

</tasks>

<verification>
Run from backend directory:
```bash
cd backend
python -c "
from app.main import app
from app.checks.router import router

# Verify router is included
routes = [r.path for r in app.routes]
print(f'App routes: {routes}')
assert '/api/check/{document_type}' in routes, 'Check route not found'

# Verify router has correct endpoint
print(f'Check router prefix: {router.prefix}')
print(f'Check router routes: {len(router.routes)}')

print('Check API integration verified!')
"
```
</verification>

<success_criteria>
1. POST /api/check/{document_type} endpoint exists
2. Endpoint accepts ExtractionResult body and returns CheckResult
3. Categories returned in fixed order per CONTEXT.md
4. Empty categories included with zero counts
5. Overall status correctly computed from error/warning counts
6. Check duration tracked in response
7. 404 returned for unknown document types
</success_criteria>

<output>
After completion, create `.planning/phases/03-design-compliance-checks/03-03-SUMMARY.md`
</output>
