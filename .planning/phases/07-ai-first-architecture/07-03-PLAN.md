---
phase: 07-ai-first-architecture
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useAIReview.ts
  - frontend/src/types/review.ts
autonomous: true

must_haves:
  truths:
    - "Hook parses SSE stream from backend"
    - "Content accumulates progressively during stream"
    - "Hook tracks streaming, complete, and error states"
    - "FormData sent with PDF file and extraction JSON"
  artifacts:
    - path: "frontend/src/hooks/useAIReview.ts"
      provides: "SSE streaming hook for AI review"
      min_lines: 60
      exports: ["useAIReview"]
    - path: "frontend/src/types/review.ts"
      provides: "Review state and section types"
      min_lines: 20
  key_links:
    - from: "frontend/src/hooks/useAIReview.ts"
      to: "/api/ai/review"
      via: "fetch POST request"
      pattern: "fetch.*api/ai/review"
---

<objective>
Create a new useAIReview hook that handles SSE streaming from the review endpoint.

Purpose: Enable real-time display of AI review content as it streams (per CONTEXT.md streaming requirement). The hook parses SSE events and accumulates text progressively.

Output: New useAIReview hook with streaming support, review types definition.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-ai-first-architecture/07-CONTEXT.md
@.planning/phases/07-ai-first-architecture/07-RESEARCH.md
@frontend/src/hooks/useAIAnalysis.ts
@frontend/src/types/extraction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create review types</name>
  <files>frontend/src/types/review.ts</files>
  <action>
Create `frontend/src/types/review.ts` with types for the new AI review system:

```typescript
/**
 * Review types for AI-first architecture.
 * AI produces prose review organized by sections.
 */

/** Parsed review sections from AI response */
export interface ReviewSections {
  overview: string;
  needsAttention: string;
  lookingGood: string;
  suggestions: string;
}

/** State of AI review process */
export interface ReviewState {
  /** Accumulated raw markdown content */
  content: string;
  /** Parsed sections (updated as content streams) */
  sections: ReviewSections;
  /** Currently streaming */
  isStreaming: boolean;
  /** Stream completed successfully */
  isComplete: boolean;
  /** Error message if failed */
  error: string | null;
}

/** Initial empty review state */
export const INITIAL_REVIEW_STATE: ReviewState = {
  content: '',
  sections: {
    overview: '',
    needsAttention: '',
    lookingGood: '',
    suggestions: '',
  },
  isStreaming: false,
  isComplete: false,
  error: null,
};

/**
 * Parse markdown content into sections.
 * Handles partial content during streaming.
 */
export function parseReviewSections(content: string): ReviewSections {
  const sections: ReviewSections = {
    overview: '',
    needsAttention: '',
    lookingGood: '',
    suggestions: '',
  };

  // Section patterns - case insensitive, flexible header matching
  const patterns = [
    { key: 'overview' as const, pattern: /###?\s*Overview\n([\s\S]*?)(?=###|$)/i },
    { key: 'needsAttention' as const, pattern: /###?\s*Needs\s*Attention\n([\s\S]*?)(?=###|$)/i },
    { key: 'lookingGood' as const, pattern: /###?\s*Looking\s*Good\n([\s\S]*?)(?=###|$)/i },
    { key: 'suggestions' as const, pattern: /###?\s*Suggestions\n([\s\S]*?)(?=###|$)/i },
  ];

  for (const { key, pattern } of patterns) {
    const match = content.match(pattern);
    if (match) {
      sections[key] = match[1].trim();
    }
  }

  return sections;
}
```
  </action>
  <verify>
- File exists at frontend/src/types/review.ts
- Exports ReviewState, ReviewSections, parseReviewSections, INITIAL_REVIEW_STATE
- TypeScript compiles without errors
  </verify>
  <done>
- Review types defined
- Section parsing function implemented
- Initial state constant exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAIReview hook with SSE streaming</name>
  <files>frontend/src/hooks/useAIReview.ts</files>
  <action>
Create `frontend/src/hooks/useAIReview.ts` that handles SSE streaming:

```typescript
import { useState, useCallback, useRef } from 'react';
import type { ExtractionResult } from '../types/extraction';
import {
  ReviewState,
  INITIAL_REVIEW_STATE,
  parseReviewSections
} from '../types/review';

/**
 * Hook for streaming AI document review.
 *
 * Sends PDF + extraction to /api/ai/review endpoint,
 * receives SSE stream, and accumulates content progressively.
 */
export function useAIReview() {
  const [state, setState] = useState<ReviewState>(INITIAL_REVIEW_STATE);
  const abortControllerRef = useRef<AbortController | null>(null);

  const startReview = useCallback(async (
    file: File,
    extraction: ExtractionResult,
    documentType: string,
    confidence: number,
  ) => {
    // Cancel any existing request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    // Reset state
    setState({
      ...INITIAL_REVIEW_STATE,
      isStreaming: true,
    });

    // Build form data
    const formData = new FormData();
    formData.append('file', file);
    formData.append('extraction', JSON.stringify(extraction));
    formData.append('document_type', documentType);
    formData.append('confidence', confidence.toString());

    try {
      const response = await fetch('/api/ai/review', {
        method: 'POST',
        body: formData,
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Review failed: ${response.status} - ${errorText}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body');
      }

      const decoder = new TextDecoder();
      let accumulatedContent = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });

        // Parse SSE format: lines starting with "data: "
        const lines = chunk.split('\n');
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (data.text) {
                accumulatedContent += data.text;
                setState(prev => ({
                  ...prev,
                  content: accumulatedContent,
                  sections: parseReviewSections(accumulatedContent),
                }));
              }
            } catch {
              // Skip malformed JSON (partial lines)
            }
          }

          // Handle complete event
          if (line.startsWith('event: complete')) {
            // Stream finished
          }
        }
      }

      // Mark as complete
      setState(prev => ({
        ...prev,
        isStreaming: false,
        isComplete: true,
      }));

    } catch (error) {
      if ((error as Error).name === 'AbortError') {
        // Request was cancelled, don't update state
        return;
      }

      setState(prev => ({
        ...prev,
        isStreaming: false,
        error: error instanceof Error ? error.message : 'Review failed',
      }));
    }
  }, []);

  const cancelReview = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    setState(prev => ({
      ...prev,
      isStreaming: false,
    }));
  }, []);

  const reset = useCallback(() => {
    cancelReview();
    setState(INITIAL_REVIEW_STATE);
  }, [cancelReview]);

  return {
    ...state,
    startReview,
    cancelReview,
    reset,
  };
}
```

**Key features:**
- SSE parsing: Handles `data:` lines with JSON payloads
- Progressive accumulation: Content builds up as stream arrives
- Section parsing: Updates parsed sections on each chunk
- Abort support: Can cancel in-flight requests
- Error handling: Catches network and API errors
  </action>
  <verify>
- File exists at frontend/src/hooks/useAIReview.ts
- Exports useAIReview function
- TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
- useAIReview hook created with SSE streaming
- Progressive content accumulation implemented
- Section parsing on each chunk
- Abort and reset capabilities
  </done>
</task>

</tasks>

<verification>
1. Both files exist in correct locations
2. TypeScript compiles: `cd frontend && npx tsc --noEmit`
3. useAIReview exports startReview, cancelReview, reset, and state properties
4. parseReviewSections handles partial content gracefully
</verification>

<success_criteria>
- Review types defined with sections structure
- useAIReview hook handles SSE streaming
- Content accumulates progressively
- Section parsing works on partial content
</success_criteria>

<output>
After completion, create `.planning/phases/07-ai-first-architecture/07-03-SUMMARY.md`
</output>
