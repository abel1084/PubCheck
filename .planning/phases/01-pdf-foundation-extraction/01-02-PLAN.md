---
phase: 01-pdf-foundation-extraction
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/services/detector.py
  - backend/app/services/document_type_detector.py
  - backend/app/api/__init__.py
  - backend/app/api/upload.py
  - backend/app/models/upload.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/upload accepts a PDF file and returns extraction results"
    - "Rasterized/flattened PDFs are rejected with 422 status and explanation"
    - "Document type is detected with confidence level (Factsheet, Policy Brief, etc.)"
    - "Upload returns all extracted data: text, images, margins, metadata"
  artifacts:
    - path: "backend/app/services/detector.py"
      provides: "Rasterized PDF detection"
      exports: ["is_rasterized_pdf"]
    - path: "backend/app/services/document_type_detector.py"
      provides: "UNEP document type detection"
      exports: ["detect_document_type", "DocumentType"]
    - path: "backend/app/api/upload.py"
      provides: "Upload endpoint"
      exports: ["router"]
    - path: "backend/app/models/upload.py"
      provides: "Upload response models"
      exports: ["UploadResponse", "RejectionResponse"]
  key_links:
    - from: "backend/app/api/upload.py"
      to: "backend/app/services/pdf_extractor.py"
      via: "PDFExtractor import"
      pattern: "from app.services.pdf_extractor import"
    - from: "backend/app/api/upload.py"
      to: "backend/app/services/detector.py"
      via: "is_rasterized_pdf import"
      pattern: "from app.services.detector import"
    - from: "backend/app/main.py"
      to: "backend/app/api/upload.py"
      via: "router include"
      pattern: "app.include_router"
---

<objective>
Implement rasterized PDF detection, UNEP document type detection, and the upload API endpoint that ties everything together.

Purpose: Users need to upload PDFs and get back extracted content with document type detection. Rasterized PDFs must be rejected early with a clear explanation (UPLD-03).

Output: Working upload endpoint that accepts PDFs, rejects rasterized ones, detects document type, and returns full extraction results.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/LEARNINGS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-pdf-foundation-extraction/01-CONTEXT.md
@.planning/phases/01-pdf-foundation-extraction/01-RESEARCH.md
@.planning/phases/01-pdf-foundation-extraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rasterized PDF detection</name>
  <files>
    backend/app/services/detector.py
  </files>
  <action>
Create `backend/app/services/detector.py` following the pattern from RESEARCH.md:

```python
import pymupdf

def is_rasterized_pdf(doc: pymupdf.Document, threshold: float = 0.95) -> tuple[bool, str]:
    """
    Detect if PDF is rasterized/flattened (image-only, no text layer).

    Heuristic: A page is rasterized if:
    - Has very little extractable text (< 10 chars)
    - AND has image(s) covering > threshold (95%) of page area

    PDF is rasterized if > 50% of pages are rasterized.

    Returns: (is_rasterized, reason)
    """
```

Implementation details:
1. Loop through all pages
2. For each page:
   - Extract text with `page.get_text("text").strip()`
   - Check if len(text) < 10 (minimal text threshold)
   - Get all images with `page.get_images(full=True)`
   - Calculate total image coverage by summing intersection of image rects with page rect
   - A page is rasterized if: no text AND image coverage >= threshold
3. PDF is rasterized if rasterized_pages > total_pages * 0.5
4. Return descriptive reason: "X/Y pages appear to be scanned images without text layers"

Edge cases to handle:
- Empty pages (no text, no images) should NOT count as rasterized
- PDFs with mixed content (some rasterized, some text) - use majority rule
  </action>
  <verify>
- `cd backend && python -c "from app.services.detector import is_rasterized_pdf; print('Import OK')"`
- Create a test with a known text-based PDF (should return False)
  </verify>
  <done>
- is_rasterized_pdf() correctly identifies rasterized PDFs
- Returns helpful reason message for rejected PDFs
- Handles edge cases (empty pages, mixed content)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement document type detection</name>
  <files>
    backend/app/services/document_type_detector.py
  </files>
  <action>
Create `backend/app/services/document_type_detector.py`:

```python
import pymupdf
import re
from enum import Enum

class DocumentType(str, Enum):
    FACTSHEET = "Factsheet"
    POLICY_BRIEF = "Policy Brief"
    WORKING_PAPER = "Working Paper"
    TECHNICAL_REPORT = "Technical Report"
    PUBLICATION = "Publication"

class Confidence(str, Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

def detect_document_type(doc: pymupdf.Document) -> tuple[DocumentType, Confidence]:
    """
    Detect UNEP document type from content analysis.

    Uses:
    - Page count heuristics
    - Keyword analysis from first 5 pages
    - ISBN presence (strongly indicates Publication)

    Returns: (document_type, confidence)
    """
```

Implementation following RESEARCH.md pattern:

1. Get page_count from doc.page_count

2. Extract sample text from first 5 pages (lowercase)

3. Check for ISBN: `re.search(r'isbn', sample_text)`

4. Define keyword indicators:
   - factsheet: ["fact sheet", "factsheet", "key facts", "at a glance"]
   - policy_brief: ["policy brief", "policy recommendations", "policy options"]
   - working_paper: ["working paper", "discussion paper", "draft"]
   - technical_report: ["technical report", "methodology", "technical annex"]
   - publication: ["publication", "published by", "copyright"]

5. Score each type by counting keyword matches

6. Apply page count heuristics:
   - 1-4 pages: +2 to factsheet
   - 4-12 pages: +1 to policy_brief
   - 50+ pages: +2 to publication, +1 to technical_report

7. If has_isbn: +3 to publication

8. Determine confidence:
   - HIGH: best_score >= 3
   - MEDIUM: best_score >= 1
   - LOW: best_score < 1 (default to Publication)
  </action>
  <verify>
- `cd backend && python -c "from app.services.document_type_detector import detect_document_type, DocumentType; print('Import OK')"`
  </verify>
  <done>
- detect_document_type() returns DocumentType enum and Confidence
- Uses multiple signals (keywords, page count, ISBN)
- Returns sensible defaults for ambiguous documents
  </done>
</task>

<task type="auto">
  <name>Task 3: Create upload endpoint</name>
  <files>
    backend/app/models/upload.py
    backend/app/api/__init__.py
    backend/app/api/upload.py
    backend/app/main.py
  </files>
  <action>
**Create upload models** in `backend/app/models/upload.py`:

```python
from pydantic import BaseModel
from typing import Literal
from app.models.extraction import ExtractionResult
from app.services.document_type_detector import DocumentType, Confidence

class UploadResponse(BaseModel):
    success: Literal[True] = True
    filename: str
    document_type: DocumentType
    confidence: Confidence
    extraction: ExtractionResult

class RejectionResponse(BaseModel):
    success: Literal[False] = False
    error: str
    message: str
    details: str
    accessibility_info: str = "https://www.w3.org/WAI/WCAG21/Techniques/pdf/"
```

**Create API router** in `backend/app/api/upload.py`:

```python
from fastapi import APIRouter, UploadFile, HTTPException
from fastapi.responses import JSONResponse
import pymupdf

from app.services.detector import is_rasterized_pdf
from app.services.document_type_detector import detect_document_type
from app.services.pdf_extractor import PDFExtractor
from app.models.upload import UploadResponse, RejectionResponse

router = APIRouter(prefix="/api", tags=["upload"])

@router.post("/upload")
async def upload_pdf(file: UploadFile):
    """
    Upload a PDF for extraction and analysis.

    Returns extraction results or rejection for rasterized PDFs.
    """
    # 1. Validate content type
    if file.content_type != "application/pdf":
        raise HTTPException(400, "Only PDF files are accepted")

    # 2. Read file content
    content = await file.read()

    # 3. Open with PyMuPDF
    try:
        doc = pymupdf.open(stream=content, filetype="pdf")
    except Exception as e:
        raise HTTPException(400, f"Invalid PDF file: {str(e)}")

    # 4. Check for rasterized content (UPLD-03)
    is_rasterized, reason = is_rasterized_pdf(doc)
    if is_rasterized:
        doc.close()
        return JSONResponse(
            status_code=422,
            content=RejectionResponse(
                error="rasterized_pdf",
                message="This PDF appears to be a scanned image without text layers.",
                details=reason
            ).model_dump()
        )

    # 5. Detect document type (UPLD-02)
    doc_type, confidence = detect_document_type(doc)

    # 6. Extract content
    extractor = PDFExtractor(content, file.filename)
    extraction = extractor.extract()

    doc.close()

    return UploadResponse(
        filename=file.filename,
        document_type=doc_type,
        confidence=confidence,
        extraction=extraction
    )
```

**Create API __init__** in `backend/app/api/__init__.py`:
```python
from app.api.upload import router as upload_router

__all__ = ["upload_router"]
```

**Update main.py** to include the router:
```python
from app.api import upload_router
app.include_router(upload_router)
```

Also ensure CORS is configured for the frontend:
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```
  </action>
  <verify>
- Start backend: `cd backend && python -m uvicorn app.main:app --reload`
- Test upload with curl:
  ```bash
  curl -X POST "http://localhost:8000/api/upload" \
    -H "Content-Type: multipart/form-data" \
    -F "file=@test.pdf"
  ```
- Should return JSON with extraction results
- Test with a rasterized PDF (if available) - should return 422
  </verify>
  <done>
- POST /api/upload accepts PDF files
- Returns 422 with explanation for rasterized PDFs
- Returns document type and confidence level
- Returns full extraction results (text, images, margins, metadata)
  </done>
</task>

</tasks>

<verification>
1. Backend runs and accepts uploads:
   ```bash
   cd backend && python -m uvicorn app.main:app --reload
   curl -X POST "http://localhost:8000/api/upload" -F "file=@sample.pdf"
   ```

2. Response includes:
   - document_type (one of the 5 UNEP types)
   - confidence (high/medium/low)
   - extraction.metadata (filename, page_count, title, etc.)
   - extraction.text_blocks (array with font info)
   - extraction.images (array with DPI)
   - extraction.margins (array per page)
   - extraction.fonts (summary array)

3. Rasterized PDF rejection works:
   - Returns 422 status
   - Includes helpful error message
   - Includes accessibility_info link
</verification>

<success_criteria>
- POST /api/upload works end-to-end
- Rasterized PDFs rejected with 422 and explanation
- Document type detected with confidence level
- All extraction data returned in response
- CORS configured for frontend access
</success_criteria>

<output>
After completion, create `.planning/phases/01-pdf-foundation-extraction/01-02-SUMMARY.md`
</output>
