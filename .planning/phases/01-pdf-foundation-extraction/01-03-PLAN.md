---
phase: 01-pdf-foundation-extraction
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/src/components/DropZone/DropZone.tsx
  - frontend/src/components/DropZone/DropZone.css
  - frontend/src/components/DropZone/index.ts
  - frontend/src/components/SortableTable/SortableTable.tsx
  - frontend/src/components/SortableTable/SortableTable.css
  - frontend/src/components/SortableTable/index.ts
autonomous: true

must_haves:
  truths:
    - "DropZone renders with dashed border and upload instructions"
    - "DropZone shows visual feedback on drag-over (border highlight)"
    - "DropZone accepts only PDF files"
    - "DropZone shows error message when file is rejected"
    - "SortableTable renders data with clickable column headers"
    - "SortableTable sorts data ascending/descending when header clicked"
  artifacts:
    - path: "frontend/src/components/DropZone/DropZone.tsx"
      provides: "Drag-and-drop file upload component"
      exports: ["DropZone"]
    - path: "frontend/src/components/SortableTable/SortableTable.tsx"
      provides: "Reusable sortable table component"
      exports: ["SortableTable"]
  key_links:
    - from: "frontend/src/components/DropZone/DropZone.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "useDropzone"
    - from: "frontend/src/components/SortableTable/SortableTable.tsx"
      to: "@tanstack/react-table"
      via: "useReactTable hook"
      pattern: "useReactTable"
---

<objective>
Create the core frontend UI components: DropZone for PDF upload and SortableTable for data display.

Purpose: These are reusable components needed by the data tabs. Building them separately enables parallel development and clean separation of concerns.

Output: Working DropZone component with react-dropzone and SortableTable component with TanStack Table.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/LEARNINGS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-pdf-foundation-extraction/01-CONTEXT.md
@.planning/phases/01-pdf-foundation-extraction/01-RESEARCH.md
@.planning/phases/01-pdf-foundation-extraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DropZone component</name>
  <files>
    frontend/src/components/DropZone/DropZone.tsx
    frontend/src/components/DropZone/DropZone.css
    frontend/src/components/DropZone/index.ts
  </files>
  <action>
Create the DropZone component following CONTEXT.md decisions:

**DropZone.tsx:**
```tsx
import { useCallback, useState } from 'react';
import { useDropzone, FileRejection } from 'react-dropzone';
import './DropZone.css';

interface DropZoneProps {
  onFileAccepted: (file: File) => void;
  isProcessing: boolean;
  error?: string | null;
}

export function DropZone({ onFileAccepted, isProcessing, error }: DropZoneProps) {
  const [rejectionMessage, setRejectionMessage] = useState<string | null>(null);

  const onDrop = useCallback((acceptedFiles: File[], rejectedFiles: FileRejection[]) => {
    setRejectionMessage(null);

    if (rejectedFiles.length > 0) {
      const rejection = rejectedFiles[0];
      const error = rejection.errors[0];
      if (error.code === 'file-invalid-type') {
        setRejectionMessage('Only PDF files are accepted');
      } else if (error.code === 'too-many-files') {
        setRejectionMessage('Please upload one file at a time');
      } else {
        setRejectionMessage(error.message);
      }
      return;
    }

    if (acceptedFiles.length > 0) {
      onFileAccepted(acceptedFiles[0]);
    }
  }, [onFileAccepted]);

  const { getRootProps, getInputProps, isDragActive, isDragAccept, isDragReject } = useDropzone({
    onDrop,
    accept: { 'application/pdf': ['.pdf'] },
    maxFiles: 1,
    disabled: isProcessing,
    multiple: false,
  });

  const displayError = error || rejectionMessage;

  return (
    <div
      {...getRootProps()}
      className={`drop-zone ${isDragActive ? 'drop-zone--active' : ''} ${isDragAccept ? 'drop-zone--accept' : ''} ${isDragReject ? 'drop-zone--reject' : ''} ${isProcessing ? 'drop-zone--processing' : ''} ${displayError ? 'drop-zone--error' : ''}`}
    >
      <input {...getInputProps()} />

      {isProcessing ? (
        <div className="drop-zone__content">
          <div className="drop-zone__spinner" />
          <p className="drop-zone__text">Processing...</p>
        </div>
      ) : displayError ? (
        <div className="drop-zone__content drop-zone__content--error">
          <p className="drop-zone__error">{displayError}</p>
          <p className="drop-zone__secondary">Drop another PDF or click to browse</p>
        </div>
      ) : isDragActive ? (
        <div className="drop-zone__content">
          <p className="drop-zone__text">Drop PDF here...</p>
        </div>
      ) : (
        <div className="drop-zone__content">
          <div className="drop-zone__icon">
            {/* Simple PDF icon using CSS */}
            <span className="drop-zone__icon-text">PDF</span>
          </div>
          <p className="drop-zone__text">Drop PDF here</p>
          <p className="drop-zone__secondary">or click to browse</p>
        </div>
      )}
    </div>
  );
}
```

**DropZone.css:**
Following CONTEXT.md: "Prominent drop zone with large dashed border area"

```css
.drop-zone {
  border: 3px dashed #ccc;
  border-radius: 12px;
  padding: 60px 40px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  background: #fafafa;
  min-height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.drop-zone:hover {
  border-color: #999;
  background: #f5f5f5;
}

/* CONTEXT.md: "Border highlight on drag-over: dashed border becomes solid/colored" */
.drop-zone--active {
  border-style: solid;
  border-color: #2196f3;
  background: #e3f2fd;
}

.drop-zone--accept {
  border-color: #4caf50;
  background: #e8f5e9;
}

.drop-zone--reject {
  border-color: #f44336;
  background: #ffebee;
}

.drop-zone--processing {
  cursor: wait;
  opacity: 0.7;
}

/* CONTEXT.md: "Rejection shown as inline message in drop zone - red message" */
.drop-zone--error {
  border-color: #f44336;
}

.drop-zone__content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.drop-zone__icon {
  width: 64px;
  height: 80px;
  background: #e0e0e0;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.drop-zone__icon::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 16px;
  height: 16px;
  background: #ccc;
  clip-path: polygon(100% 0, 0 100%, 100% 100%);
}

.drop-zone__icon-text {
  font-size: 14px;
  font-weight: bold;
  color: #666;
}

.drop-zone__text {
  font-size: 18px;
  color: #333;
  margin: 0;
}

/* CONTEXT.md: "Secondary 'or click to browse' text link" */
.drop-zone__secondary {
  font-size: 14px;
  color: #666;
  margin: 0;
}

.drop-zone__error {
  color: #c62828;
  font-size: 16px;
  font-weight: 500;
  margin: 0;
}

.drop-zone__spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #e0e0e0;
  border-top-color: #2196f3;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
```

**index.ts:**
```tsx
export { DropZone } from './DropZone';
```
  </action>
  <verify>
- Files exist in correct locations
- `cd frontend && npm run build` succeeds (no TypeScript errors)
- Manually test by importing in App.tsx and checking browser
  </verify>
  <done>
- DropZone renders with dashed border and "Drop PDF here" text
- Border changes on drag-over (solid, colored)
- Only accepts PDF files
- Shows error message for rejected files
- Shows spinner during processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SortableTable component</name>
  <files>
    frontend/src/components/SortableTable/SortableTable.tsx
    frontend/src/components/SortableTable/SortableTable.css
    frontend/src/components/SortableTable/index.ts
  </files>
  <action>
Create the SortableTable component following RESEARCH.md patterns:

**SortableTable.tsx:**
```tsx
import { useState } from 'react';
import {
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  flexRender,
  SortingState,
  ColumnDef,
} from '@tanstack/react-table';
import './SortableTable.css';

interface SortableTableProps<T> {
  data: T[];
  columns: ColumnDef<T, unknown>[];
  defaultSort?: SortingState;
  emptyMessage?: string;
}

export function SortableTable<T>({
  data,
  columns,
  defaultSort = [],
  emptyMessage = 'No data available'
}: SortableTableProps<T>) {
  const [sorting, setSorting] = useState<SortingState>(defaultSort);

  const table = useReactTable({
    data,
    columns,
    state: { sorting },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
  });

  if (data.length === 0) {
    return (
      <div className="sortable-table__empty">
        {emptyMessage}
      </div>
    );
  }

  return (
    <div className="sortable-table-container">
      <table className="sortable-table">
        <thead>
          {table.getHeaderGroups().map(headerGroup => (
            <tr key={headerGroup.id}>
              {headerGroup.headers.map(header => {
                const canSort = header.column.getCanSort();
                const sortDirection = header.column.getIsSorted();

                return (
                  <th
                    key={header.id}
                    onClick={canSort ? header.column.getToggleSortingHandler() : undefined}
                    className={`sortable-table__header ${canSort ? 'sortable-table__header--sortable' : ''} ${sortDirection ? 'sortable-table__header--sorted' : ''}`}
                  >
                    <div className="sortable-table__header-content">
                      {flexRender(header.column.columnDef.header, header.getContext())}
                      {canSort && (
                        <span className="sortable-table__sort-indicator">
                          {sortDirection === 'asc' && ' ▲'}
                          {sortDirection === 'desc' && ' ▼'}
                          {!sortDirection && ' ⇅'}
                        </span>
                      )}
                    </div>
                  </th>
                );
              })}
            </tr>
          ))}
        </thead>
        <tbody>
          {table.getRowModel().rows.map(row => (
            <tr key={row.id} className="sortable-table__row">
              {row.getVisibleCells().map(cell => (
                <td key={cell.id} className="sortable-table__cell">
                  {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

**SortableTable.css:**
Following CONTEXT.md: "Tables are sortable by column headers"

```css
.sortable-table-container {
  overflow-x: auto;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
}

.sortable-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.sortable-table__header {
  background: #f5f5f5;
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: #333;
  border-bottom: 2px solid #e0e0e0;
  white-space: nowrap;
}

.sortable-table__header--sortable {
  cursor: pointer;
  user-select: none;
}

.sortable-table__header--sortable:hover {
  background: #eeeeee;
}

.sortable-table__header--sorted {
  background: #e3f2fd;
}

.sortable-table__header-content {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sortable-table__sort-indicator {
  color: #666;
  font-size: 12px;
}

.sortable-table__row {
  border-bottom: 1px solid #e0e0e0;
}

.sortable-table__row:hover {
  background: #fafafa;
}

.sortable-table__row:last-child {
  border-bottom: none;
}

.sortable-table__cell {
  padding: 12px 16px;
  color: #333;
}

.sortable-table__empty {
  padding: 40px;
  text-align: center;
  color: #666;
  font-style: italic;
}

/* For numeric columns, align right */
.sortable-table__cell--numeric {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

/* For status/severity columns */
.sortable-table__cell--warning {
  color: #f57c00;
}

.sortable-table__cell--error {
  color: #c62828;
}

.sortable-table__cell--success {
  color: #2e7d32;
}
```

**index.ts:**
```tsx
export { SortableTable } from './SortableTable';
```
  </action>
  <verify>
- Files exist in correct locations
- `cd frontend && npm run build` succeeds (no TypeScript errors)
- Create a simple test by rendering SortableTable with mock data in App.tsx
  </verify>
  <done>
- SortableTable renders with column headers and data rows
- Clicking sortable headers toggles sort direction
- Sort indicator shows current sort state (▲, ▼, or ⇅)
- Empty state shows message when no data
  </done>
</task>

</tasks>

<verification>
1. Frontend builds without errors:
   ```bash
   cd frontend && npm run build
   ```

2. Components can be imported and rendered:
   - Add both components to App.tsx temporarily
   - DropZone shows with upload UI
   - SortableTable renders with test data

3. Interactive behavior works:
   - DropZone highlights on drag
   - Table sorts on header click
</verification>

<success_criteria>
- DropZone component complete with all states (idle, active, accept, reject, processing, error)
- SortableTable component complete with sorting functionality
- Both components have proper TypeScript types
- CSS follows CONTEXT.md decisions (dashed border, sort indicators)
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-pdf-foundation-extraction/01-03-SUMMARY.md`
</output>
