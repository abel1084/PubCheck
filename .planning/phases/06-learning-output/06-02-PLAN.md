---
phase: 06-learning-output
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/output/__init__.py
  - backend/app/output/models.py
  - backend/app/output/pdf_annotator.py
  - backend/app/output/router.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/output/annotate accepts issues and returns annotated PDF"
    - "Sticky notes appear at issue locations (red for errors, yellow for warnings)"
    - "Summary annotation on page 1 shows error/warning counts"
    - "Overlapping annotations are vertically offset"
  artifacts:
    - path: "backend/app/output/models.py"
      provides: "AnnotationRequest and IssueAnnotation models"
      exports: ["AnnotationRequest", "IssueAnnotation"]
    - path: "backend/app/output/pdf_annotator.py"
      provides: "PDFAnnotator class for sticky note generation"
      exports: ["PDFAnnotator"]
    - path: "backend/app/output/router.py"
      provides: "REST endpoint for PDF annotation"
      exports: ["router"]
  key_links:
    - from: "backend/app/output/router.py"
      to: "backend/app/output/pdf_annotator.py"
      via: "PDFAnnotator instantiation"
      pattern: "PDFAnnotator\\(pdf_bytes\\)"
    - from: "backend/app/main.py"
      to: "backend/app/output/router.py"
      via: "include_router"
      pattern: "app\\.include_router\\(output_router\\)"
---

<objective>
Create backend PDF annotation module for generating annotated PDFs with sticky notes.

Purpose: Enable users to generate an annotated PDF with sticky notes at issue locations, color-coded by severity.
Output: PDF annotator service with REST endpoint that accepts issues and returns annotated PDF bytes.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-learning-output/06-CONTEXT.md
@.planning/phases/06-learning-output/06-RESEARCH.md

# Existing patterns
@backend/app/main.py (router registration)
@backend/app/services/extraction.py (PyMuPDF usage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output models and PDF annotator</name>
  <files>
    backend/app/output/__init__.py
    backend/app/output/models.py
    backend/app/output/pdf_annotator.py
  </files>
  <action>
Create the output module structure:

1. Create `backend/app/output/__init__.py` with empty file.

2. Create `backend/app/output/models.py` with Pydantic models:
   - `IssueAnnotation`:
     - page (int): 1-indexed page number
     - x (Optional[float]): x coordinate, None if no location
     - y (Optional[float]): y coordinate, None if no location
     - message (str): issue message to display
     - severity (Literal["error", "warning"])
     - reviewer_note (Optional[str]): user's note if any
   - `AnnotationRequest`:
     - issues (List[IssueAnnotation]): issues to annotate

3. Create `backend/app/output/pdf_annotator.py` with `PDFAnnotator` class:

```python
import pymupdf
from typing import Optional, Tuple

class PDFAnnotator:
    """Adds sticky note annotations to PDF pages."""

    STACK_OFFSET = 20.0  # Vertical offset for overlapping notes
    DEFAULT_MARGIN = (20.0, 20.0)  # Default position when no coordinates

    def __init__(self, file_bytes: bytes):
        self._doc = pymupdf.open(stream=file_bytes, filetype="pdf")
        self._used_positions: dict[int, list[float]] = {}

    def add_issue_annotation(
        self,
        page_num: int,  # 1-indexed
        point: Optional[Tuple[float, float]],
        message: str,
        severity: str,
        reviewer_note: Optional[str] = None
    ) -> None:
        """Add a sticky note for an issue."""
        page = self._doc[page_num - 1]

        # Build annotation text
        text = message
        if reviewer_note:
            text += f"\n\nReviewer note: {reviewer_note}"

        # Determine position
        if point and point[0] is not None and point[1] is not None:
            x, y = point
            # Clamp to page bounds
            rect = page.rect
            x = max(10, min(x, rect.width - 30))
            y = max(10, min(y, rect.height - 30))
        else:
            x, y = self.DEFAULT_MARGIN

        # Offset if position already used
        y = self._get_available_y(page_num, y)

        # Create annotation
        annot = page.add_text_annot((x, y), text, icon="Note")

        # Color by severity (RGB 0-1)
        color = (1, 0, 0) if severity == "error" else (1, 1, 0)
        annot.set_colors(stroke=color)
        annot.update()

    def add_summary_annotation(self, error_count: int, warning_count: int) -> None:
        """Add summary annotation to page 1."""
        page = self._doc[0]
        summary_text = f"Review Summary\n{error_count} Errors, {warning_count} Warnings"
        annot = page.add_text_annot((20.0, 20.0), summary_text, icon="Note")
        annot.set_colors(stroke=(0, 0, 1))  # Blue for summary
        annot.update()
        # Reserve this position
        self._used_positions.setdefault(1, []).append(20.0)

    def _get_available_y(self, page_num: int, desired_y: float) -> float:
        """Find available Y position, offsetting if needed."""
        if page_num not in self._used_positions:
            self._used_positions[page_num] = []

        used = self._used_positions[page_num]
        y = desired_y

        while any(abs(y - used_y) < self.STACK_OFFSET for used_y in used):
            y += self.STACK_OFFSET

        used.append(y)
        return y

    def save(self) -> bytes:
        """Return annotated PDF as bytes."""
        return self._doc.tobytes()

    def close(self) -> None:
        """Close the document."""
        self._doc.close()
```
  </action>
  <verify>
    - Python imports successfully: `python -c "from app.output.models import AnnotationRequest, IssueAnnotation; from app.output.pdf_annotator import PDFAnnotator"`
  </verify>
  <done>
    - IssueAnnotation and AnnotationRequest models exist
    - PDFAnnotator can add colored sticky notes at positions
    - Overlapping notes are vertically offset
    - Summary annotation added to page 1
  </done>
</task>

<task type="auto">
  <name>Task 2: Create output API router and register</name>
  <files>
    backend/app/output/router.py
    backend/app/main.py
  </files>
  <action>
1. Create `backend/app/output/router.py`:
   - Create APIRouter with prefix="/api/output" and tags=["output"]

   Endpoint:
   - `POST /annotate`: Accepts multipart form with:
     - `pdf` (UploadFile): The original PDF file
     - `issues` (str): JSON string of AnnotationRequest
   - Returns: StreamingResponse with annotated PDF, content-disposition header for download

   Implementation:
   ```python
   from fastapi import APIRouter, UploadFile, File, Form
   from fastapi.responses import StreamingResponse
   import io
   import json

   from .models import AnnotationRequest, IssueAnnotation
   from .pdf_annotator import PDFAnnotator

   router = APIRouter(prefix="/api/output", tags=["output"])

   @router.post("/annotate")
   async def annotate_pdf(
       pdf: UploadFile = File(...),
       issues: str = Form(...)
   ):
       # Parse issues JSON
       request = AnnotationRequest.model_validate_json(issues)

       # Read PDF bytes
       pdf_bytes = await pdf.read()

       # Create annotator
       annotator = PDFAnnotator(pdf_bytes)

       try:
           # Count errors and warnings
           error_count = sum(1 for i in request.issues if i.severity == "error")
           warning_count = len(request.issues) - error_count

           # Add summary annotation first
           if request.issues:
               annotator.add_summary_annotation(error_count, warning_count)

           # Add issue annotations
           for issue in request.issues:
               point = (issue.x, issue.y) if issue.x is not None else None
               annotator.add_issue_annotation(
                   page_num=issue.page,
                   point=point,
                   message=issue.message,
                   severity=issue.severity,
                   reviewer_note=issue.reviewer_note
               )

           # Get annotated PDF
           result_bytes = annotator.save()
       finally:
           annotator.close()

       # Generate filename
       original_name = pdf.filename or "document.pdf"
       base_name = original_name.rsplit(".", 1)[0]
       annotated_name = f"{base_name}_annotated.pdf"

       return StreamingResponse(
           io.BytesIO(result_bytes),
           media_type="application/pdf",
           headers={
               "Content-Disposition": f'attachment; filename="{annotated_name}"'
           }
       )
   ```

2. Update `backend/app/main.py`:
   - Import: `from app.output.router import router as output_router`
   - Add: `app.include_router(output_router)`
  </action>
  <verify>
    - Start server
    - Create a test with curl (multipart form):
      `curl -X POST http://localhost:8003/api/output/annotate -F "pdf=@test.pdf" -F 'issues={"issues":[{"page":1,"message":"Test issue","severity":"error"}]}' --output test_annotated.pdf`
    - Open test_annotated.pdf in PDF viewer and verify sticky note exists
  </verify>
  <done>
    - POST /api/output/annotate endpoint functional
    - Returns annotated PDF with sticky notes
    - Router registered in main.py
  </done>
</task>

</tasks>

<verification>
- [ ] `python -c "from app.output.pdf_annotator import PDFAnnotator"` succeeds
- [ ] Server starts without errors
- [ ] POST /api/output/annotate accepts PDF + issues JSON
- [ ] Returned PDF has sticky notes at specified locations
- [ ] Error notes are red, warning notes are yellow
- [ ] Summary annotation on page 1 shows counts
- [ ] Filename has _annotated suffix
</verification>

<success_criteria>
- Backend output module complete with models, annotator, and router
- PDF annotation with colored sticky notes working
- Overlapping notes properly offset
- Summary annotation on page 1
</success_criteria>

<output>
After completion, create `.planning/phases/06-learning-output/06-02-SUMMARY.md`
</output>
