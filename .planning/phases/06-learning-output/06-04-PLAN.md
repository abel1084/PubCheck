---
phase: 06-learning-output
plan: 04
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - frontend/src/components/GenerateReport/ProgressModal.tsx
  - frontend/src/components/GenerateReport/ProgressModal.css
  - frontend/src/hooks/useGenerateReport.ts
  - frontend/src/types/output.ts
  - frontend/src/components/CheckResults/ReviewSummaryBar.tsx
  - frontend/src/components/CheckResults/CheckResults.css
autonomous: true

must_haves:
  truths:
    - "User can click Generate Report button in summary bar"
    - "Progress modal appears during PDF generation"
    - "Annotated PDF downloads automatically on completion"
    - "Button is disabled when no issues are selected"
  artifacts:
    - path: "frontend/src/components/GenerateReport/ProgressModal.tsx"
      provides: "Modal dialog showing generation progress"
      exports: ["ProgressModal"]
    - path: "frontend/src/hooks/useGenerateReport.ts"
      provides: "Hook for PDF generation with progress state"
      exports: ["useGenerateReport"]
    - path: "frontend/src/types/output.ts"
      provides: "Output generation TypeScript types"
      exports: ["IssueAnnotation", "GenerateReportState"]
  key_links:
    - from: "frontend/src/components/CheckResults/ReviewSummaryBar.tsx"
      to: "frontend/src/hooks/useGenerateReport.ts"
      via: "hook usage for generate action"
      pattern: "useGenerateReport"
    - from: "frontend/src/hooks/useGenerateReport.ts"
      to: "/api/output/annotate"
      via: "fetch POST with FormData"
      pattern: "fetch.*api/output/annotate"
---

<objective>
Create frontend PDF generation integration with progress modal and download.

Purpose: Enable users to generate and download annotated PDFs with selected issues as sticky notes.
Output: Progress modal, useGenerateReport hook, wired Generate Report button.
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-learning-output/06-CONTEXT.md
@.planning/phases/06-learning-output/06-RESEARCH.md

# Existing components
@frontend/src/components/CheckResults/ReviewSummaryBar.tsx (has Generate Report button)
@frontend/src/hooks/useReviewState.ts (selection state)
@frontend/src/types/checks.ts (CheckIssue type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output types, ProgressModal, and useGenerateReport hook</name>
  <files>
    frontend/src/types/output.ts
    frontend/src/components/GenerateReport/ProgressModal.tsx
    frontend/src/components/GenerateReport/ProgressModal.css
    frontend/src/hooks/useGenerateReport.ts
  </files>
  <action>
1. Create `frontend/src/types/output.ts`:
```typescript
/**
 * TypeScript types for output generation.
 */

export interface IssueAnnotation {
  page: number;
  x: number | null;
  y: number | null;
  message: string;
  severity: 'error' | 'warning';
  reviewer_note?: string;
}

export interface GenerateReportState {
  isGenerating: boolean;
  error: string | null;
}
```

2. Create `frontend/src/components/GenerateReport/ProgressModal.tsx`:
```typescript
import { useEffect, useRef } from 'react';
import './ProgressModal.css';

interface ProgressModalProps {
  isOpen: boolean;
  message: string;
}

/**
 * Modal dialog showing indeterminate progress during PDF generation.
 * Uses native dialog element for accessibility.
 */
export function ProgressModal({ isOpen, message }: ProgressModalProps) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useEffect(() => {
    const dialog = dialogRef.current;
    if (!dialog) return;

    if (isOpen && !dialog.open) {
      dialog.showModal();
    } else if (!isOpen && dialog.open) {
      dialog.close();
    }
  }, [isOpen]);

  return (
    <dialog ref={dialogRef} className="progress-modal">
      <div className="progress-modal__content">
        <div className="progress-modal__spinner" aria-hidden="true" />
        <p className="progress-modal__message">{message}</p>
      </div>
    </dialog>
  );
}
```

3. Create `frontend/src/components/GenerateReport/ProgressModal.css`:
```css
.progress-modal {
  border: none;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  max-width: 300px;
}

.progress-modal::backdrop {
  background: rgba(0, 0, 0, 0.5);
}

.progress-modal__content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.progress-modal__spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #e0e0e0;
  border-top-color: #1976d2;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.progress-modal__message {
  margin: 0;
  color: #333;
  font-size: 0.95rem;
  text-align: center;
}
```

4. Create `frontend/src/hooks/useGenerateReport.ts`:
```typescript
import { useState, useCallback } from 'react';
import { toast } from 'sonner';
import type { CheckIssue, CheckCategory } from '../types/checks';
import type { IssueAnnotation } from '../types/output';

interface UseGenerateReportReturn {
  isGenerating: boolean;
  error: string | null;
  generateReport: (
    pdfFile: File,
    categories: CheckCategory[],
    selectedIds: Set<string>,
    notes: Record<string, string>,
    getIssueId: (issue: CheckIssue, categoryId: string, index: number) => string
  ) => Promise<void>;
}

export function useGenerateReport(): UseGenerateReportReturn {
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const generateReport = useCallback(async (
    pdfFile: File,
    categories: CheckCategory[],
    selectedIds: Set<string>,
    notes: Record<string, string>,
    getIssueId: (issue: CheckIssue, categoryId: string, index: number) => string
  ) => {
    setIsGenerating(true);
    setError(null);

    try {
      // Build annotations from selected issues
      const annotations: IssueAnnotation[] = [];

      for (const category of categories) {
        category.issues.forEach((issue, index) => {
          const issueId = getIssueId(issue, category.category_id, index);
          if (selectedIds.has(issueId)) {
            // For each page the issue occurs on
            for (const page of issue.pages) {
              annotations.push({
                page,
                x: null,  // No coordinates available from CheckIssue
                y: null,
                message: issue.message,
                severity: issue.severity,
                reviewer_note: notes[issueId] || undefined,
              });
            }
          }
        });
      }

      if (annotations.length === 0) {
        throw new Error('No issues selected');
      }

      // Create form data
      const formData = new FormData();
      formData.append('pdf', pdfFile);
      formData.append('issues', JSON.stringify({ issues: annotations }));

      // Call API
      const response = await fetch('/api/output/annotate', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to generate annotated PDF');
      }

      // Get blob and trigger download
      const blob = await response.blob();
      const contentDisposition = response.headers.get('Content-Disposition');
      const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
      const filename = filenameMatch?.[1] || 'annotated.pdf';

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast.success('Annotated PDF downloaded');
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Unknown error';
      setError(message);
      toast.error(`Failed to generate report: ${message}`);
    } finally {
      setIsGenerating(false);
    }
  }, []);

  return { isGenerating, error, generateReport };
}
```
  </action>
  <verify>
    - TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
    - output.ts types exported
    - ProgressModal component with spinner animation
    - useGenerateReport hook with PDF download logic
    - Toast notifications on success/error
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Generate Report button in ReviewSummaryBar</name>
  <files>
    frontend/src/components/CheckResults/ReviewSummaryBar.tsx
    frontend/src/components/CheckResults/CheckResults.css
  </files>
  <action>
1. Update `frontend/src/components/CheckResults/ReviewSummaryBar.tsx`:
   - Add new prop: `onGenerateReport: () => void`
   - Add new prop: `isGenerating: boolean`
   - Wire existing Generate Report button:
     - onClick calls onGenerateReport
     - disabled when selectedCount === 0 OR isGenerating
     - Show "Generating..." text when isGenerating

Update the button:
```tsx
<button
  type="button"
  className="review-summary-bar__generate-btn"
  onClick={onGenerateReport}
  disabled={counts.selected === 0 || isGenerating}
  title={counts.selected === 0 ? "Select issues to include in report" : "Generate annotated PDF"}
>
  {isGenerating ? 'Generating...' : 'Generate Report'}
</button>
```

2. Update interface to include new props:
```typescript
interface ReviewSummaryBarProps {
  counts: ReviewCounts;
  severityFilter: SeverityFilter;
  onSeverityFilterChange: (filter: SeverityFilter) => void;
  onSelectAllVisible: () => void;
  onDeselectAll: () => void;
  onGenerateReport: () => void;
  isGenerating: boolean;
}
```

3. Add CSS for generating state in CheckResults.css (if not already present):
```css
.review-summary-bar__generate-btn:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}
```
  </action>
  <verify>
    - TypeScript compiles: `cd frontend && npx tsc --noEmit`
    - Button shows "Generating..." when isGenerating=true
    - Button disabled when no issues selected
  </verify>
  <done>
    - ReviewSummaryBar accepts onGenerateReport and isGenerating props
    - Button properly disabled and shows loading state
    - Ready for integration in CheckResults
  </done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] ProgressModal renders with spinner
- [ ] useGenerateReport hook builds annotations correctly
- [ ] Generate Report button shows disabled/loading states
- [ ] PDF download triggers on successful generation
</verification>

<success_criteria>
- ProgressModal component complete with accessible dialog
- useGenerateReport hook with FormData upload and blob download
- ReviewSummaryBar wired for generation callback
- Toast notifications for success/error
</success_criteria>

<output>
After completion, create `.planning/phases/06-learning-output/06-04-SUMMARY.md`
</output>
