---
phase: 09-chunked-document-review
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - backend/app/ai/router.py
  - frontend/src/hooks/useAIReview.ts
autonomous: true

must_haves:
  truths:
    - "SSE events include chunk progress for large documents"
    - "Frontend displays chunk progress during chunked review"
    - "Small documents work unchanged (no chunking)"
  artifacts:
    - path: "backend/app/ai/router.py"
      provides: "SSE events for chunk progress"
      exports: ["generate_review_events"]
    - path: "frontend/src/hooks/useAIReview.ts"
      provides: "Hook handles chunk progress events"
      exports: ["useAIReview"]
  key_links:
    - from: "frontend/src/hooks/useAIReview.ts"
      to: "backend/app/ai/router.py"
      via: "SSE event stream"
      pattern: "event.*chunk_progress"
    - from: "frontend/src/hooks/useAIReview.ts"
      to: "frontend/src/types/review.ts"
      via: "type import"
      pattern: "import.*ChunkProgress"
---

<objective>
Wire chunk progress events through the API and update frontend to display chunk progress.

Purpose: Show users real-time progress as chunks complete during large document review
Output: Updated router with chunk event handling, updated hook with chunk progress state management
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-chunked-document-review/09-RESEARCH.md
@.planning/phases/09-chunked-document-review/09-02-SUMMARY.md
@.planning/phases/09-chunked-document-review/09-03-SUMMARY.md
@backend/app/ai/router.py
@frontend/src/hooks/useAIReview.ts
@frontend/src/types/review.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update router to handle chunked review events</name>
  <files>backend/app/ai/router.py</files>
  <action>
Update generate_review_events function to handle the new event types from chunked review:

The review_document generator now yields JSON-encoded event objects for chunked documents.
Detect if we're in chunked mode by checking for event objects, then emit appropriate SSE events.

```python
async def generate_review_events(
    pdf_bytes: bytes,
    extraction: ExtractionResult,
    document_type: str,
    confidence: float,
    output_format: str,
) -> AsyncGenerator[dict, None]:
    """
    Generate SSE events from AI review stream.

    Handles both regular text streaming and chunked review events.

    Yields:
        SSE event dicts with 'event' and 'data' keys
    """
    try:
        async for item in review_document(
            pdf_bytes=pdf_bytes,
            extraction=extraction,
            document_type=document_type,
            confidence=confidence,
            output_format=output_format,
        ):
            # Check if item is JSON event object (chunked mode)
            # vs plain text chunk (non-chunked mode)
            try:
                event_data = json.loads(item)
                event_type = event_data.pop("event", "text")

                yield {
                    "event": event_type,
                    "data": json.dumps(event_data),
                }
            except json.JSONDecodeError:
                # Plain text chunk (non-chunked review)
                yield {
                    "event": "text",
                    "data": json.dumps({"text": item}),
                }

        # Send completion event (only for non-chunked, chunked sends its own)
        # The chunked review already sends complete event, so check last item

    except AIConfigurationError as e:
        logger.error(f"AI configuration error: {e}")
        yield {
            "event": "error",
            "data": json.dumps({"error": str(e), "type": "configuration"}),
        }

    except AIClientError as e:
        logger.error(f"AI client error: {e}")
        yield {
            "event": "error",
            "data": json.dumps({"error": str(e), "type": "api"}),
        }

    except Exception as e:
        logger.error(f"Unexpected error in review: {e}")
        logger.error(traceback.format_exc())
        yield {
            "event": "error",
            "data": json.dumps({"error": str(e), "type": "unknown"}),
        }
```

The key change: detect JSON event objects from chunked review vs plain text from non-chunked review.

Chunked review emits events:
- review_start: {"total_chunks": N}
- chunk_progress: {"chunk": N, "total": M, "pages": "X-Y", "status": "..."}
- text: {"text": "merged content"}
- complete: {"status": "complete|partial", ...}

Non-chunked review emits plain text chunks that get wrapped in text events.
  </action>
  <verify>
Run: python -c "from app.ai.router import generate_review_events; print('Function exists')"
Expected: Function exists
  </verify>
  <done>
generate_review_events handles both chunked and non-chunked review modes.
Chunked mode events are passed through with proper event types.
Non-chunked text chunks are wrapped in text events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useAIReview hook to handle chunk progress</name>
  <files>frontend/src/hooks/useAIReview.ts</files>
  <action>
Update the hook to handle new SSE events and track chunk progress:

1. Import ChunkProgress type:
```typescript
import {
  AIReviewState,
  INITIAL_AI_REVIEW_STATE,
  parseReviewSections,
  parseReviewIssues,
  ChunkProgress,
} from '../types/review';
```

2. Update SSE parsing to handle new event types:

```typescript
// Inside the SSE processing loop:

for (const line of lines) {
  // Handle event type lines
  if (line.startsWith('event: ')) {
    currentEventType = line.slice(7).trim();
    continue;
  }

  if (line.startsWith('data: ')) {
    try {
      const data = JSON.parse(line.slice(6));

      switch (currentEventType) {
        case 'review_start':
          // Large document - chunked review starting
          setState(prev => ({
            ...prev,
            isChunked: true,
            totalChunks: data.total_chunks || 0,
            completedChunks: 0,
            chunkProgress: [],
          }));
          break;

        case 'chunk_progress':
          // Chunk completed or failed
          const progress: ChunkProgress = {
            chunk: data.chunk,
            total: data.total,
            startPage: parseInt(data.pages?.split('-')[0] || '1'),
            endPage: parseInt(data.pages?.split('-')[1] || '1'),
            success: data.status === 'complete',
            error: data.error,
          };
          setState(prev => ({
            ...prev,
            completedChunks: prev.completedChunks + 1,
            chunkProgress: [...prev.chunkProgress, progress],
          }));
          break;

        case 'text':
          if (data.text) {
            accumulatedContent += data.text;
            setState(prev => ({
              ...prev,
              content: accumulatedContent,
              sections: parseReviewSections(accumulatedContent),
            }));
          }
          break;

        case 'complete':
          // Review finished
          setState(prev => ({
            ...prev,
            isStreaming: false,
            isComplete: true,
            issues: parseReviewIssues(prev.content),
          }));
          break;

        case 'error':
          setState(prev => ({
            ...prev,
            isStreaming: false,
            error: data.error || 'Unknown error',
          }));
          break;

        default:
          // Legacy text event (backwards compatibility)
          if (data.text) {
            accumulatedContent += data.text;
            setState(prev => ({
              ...prev,
              content: accumulatedContent,
              sections: parseReviewSections(accumulatedContent),
            }));
          }
      }

      currentEventType = 'text'; // Reset to default
    } catch {
      // Skip malformed JSON
    }
  }
}
```

3. Track currentEventType outside the loop:
```typescript
let accumulatedContent = '';
let currentEventType = 'text';
```

4. Update the reset state to include chunk fields:
```typescript
// In reset function
setState(INITIAL_AI_REVIEW_STATE);
```

This ensures backwards compatibility with non-chunked reviews while supporting chunk progress.
  </action>
  <verify>
Run: cd frontend && npx tsc --noEmit src/hooks/useAIReview.ts
Expected: No type errors
  </verify>
  <done>
Hook imports ChunkProgress type.
SSE parser handles review_start, chunk_progress, text, complete, error events.
Chunk progress state updated as chunks complete.
Backwards compatible with non-chunked reviews.
  </done>
</task>

</tasks>

<verification>
1. Backend router compiles: `python -c "from app.ai.router import *"`
2. Frontend hook compiles: `cd frontend && npx tsc --noEmit`
3. Router handles JSON event objects from chunked review
4. Hook updates chunk progress state for chunk_progress events
5. Non-chunked reviews still work (text events wrapped correctly)
</verification>

<success_criteria>
- Router detects chunked vs non-chunked mode from event format
- Chunked review events (review_start, chunk_progress) passed through correctly
- Hook tracks totalChunks, completedChunks, chunkProgress state
- ChunkProgress objects created from chunk_progress events
- Non-chunked reviews work unchanged (backwards compatible)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-chunked-document-review/09-04-SUMMARY.md`
</output>
