---
phase: 09-chunked-document-review
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/ai/chunker.py
  - backend/app/ai/prompts.py
autonomous: true

must_haves:
  truths:
    - "Chunker correctly calculates chunk ranges for documents over 40 pages"
    - "Chunk prompts include actual page numbers, not chunk-relative"
    - "First chunk prompt includes document-wide checks, subsequent do not"
  artifacts:
    - path: "backend/app/ai/chunker.py"
      provides: "PDF chunking logic with page range calculation and extraction filtering"
      exports: ["DocumentChunker", "extract_page_range", "filter_extraction_for_chunk"]
    - path: "backend/app/ai/prompts.py"
      provides: "Chunk-aware prompt building"
      exports: ["build_chunk_user_prompt"]
  key_links:
    - from: "backend/app/ai/chunker.py"
      to: "pymupdf.Document.select"
      via: "PDF page subsetting"
      pattern: "doc\.select\("
---

<objective>
Create the chunking foundation for large document review.

Purpose: Enable splitting large PDFs (>40 pages) into reviewable chunks with context overlap
Output: chunker.py module with page range calculation, PDF extraction, and extraction filtering; chunk-aware prompt function in prompts.py
</objective>

<execution_context>
@C:\Users\abelb\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abelb\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-chunked-document-review/09-RESEARCH.md
@backend/app/ai/prompts.py
@backend/app/models/extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DocumentChunker class and helper functions</name>
  <files>backend/app/ai/chunker.py</files>
  <action>
Create new chunker.py module with:

1. **DocumentChunker class** with constants:
   - PAGES_PER_CHUNK = 35 (conservative for 1M token limit)
   - OVERLAP_PAGES = 2 (context continuity)
   - PAGE_THRESHOLD = 40 (trigger chunking above this)
   - MAX_CONCURRENT = 2 (parallel chunk reviews)

2. **needs_chunking(page_count: int) -> bool**
   - Returns True if page_count > PAGE_THRESHOLD

3. **calculate_chunks(page_count: int) -> list[tuple[int, int]]**
   - Returns list of (start_page, end_page) tuples (0-indexed)
   - Each chunk is PAGES_PER_CHUNK pages
   - Overlap between chunks by OVERLAP_PAGES
   - Example: 105 pages -> [(0, 35), (33, 68), (66, 101), (99, 105)]

4. **extract_page_range(pdf_bytes: bytes, start: int, end: int) -> bytes**
   - Use PyMuPDF doc.select() to extract pages [start, end)
   - Write to BytesIO buffer and return bytes
   - Handle document open/close properly

5. **filter_extraction_for_chunk(extraction: ExtractionResult, start_page: int, end_page: int) -> ExtractionResult**
   - Filter text_blocks, images, margins to only include data for pages [start_page, end_page) (0-indexed)
   - Keep page numbers as ACTUAL document pages (don't renumber to chunk-relative)
   - The extraction data uses 1-indexed page numbers, so filter for pages in range [start_page+1, end_page] inclusive
   - Copy metadata but update page_count to chunk size
   - Keep fonts summary as-is (document-wide)

Import ExtractionResult, DocumentMetadata, TextBlock, ImageInfo, PageMargins from app.models.extraction.
  </action>
  <verify>
Run: python -c "from app.ai.chunker import DocumentChunker, extract_page_range, filter_extraction_for_chunk; c = DocumentChunker(); print(c.calculate_chunks(105)); print(c.needs_chunking(30)); print(c.needs_chunking(50))"
Expected: [(0, 35), (33, 68), (66, 101), (99, 105)], False, True
  </verify>
  <done>
DocumentChunker class exists with needs_chunking, calculate_chunks methods.
extract_page_range function creates subset PDFs in memory using PyMuPDF select().
filter_extraction_for_chunk filters extraction data while preserving actual page numbers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add chunk-aware prompt building function</name>
  <files>backend/app/ai/prompts.py</files>
  <action>
Add new function build_chunk_user_prompt() to prompts.py:

```python
def build_chunk_user_prompt(
    extraction_json: str,
    document_type: str,
    confidence: float,
    output_format: str,
    dpi_min: int,
    chunk_start: int,  # 1-indexed actual page number
    chunk_end: int,    # 1-indexed actual page number (inclusive)
    is_first_chunk: bool,
    total_chunks: int,
    chunk_number: int,  # 1-indexed chunk number
) -> str:
```

Prompt content:
1. Chunk context header: "You are reviewing **pages {chunk_start}-{chunk_end}** of a larger document (chunk {chunk_number} of {total_chunks})."
2. Page number instruction: "Page numbers in your findings should use the ACTUAL page numbers ({chunk_start}-{chunk_end}), not relative numbers starting from 1."
3. If is_first_chunk:
   - Include: "This is the FIRST chunk. Include document-wide checks: ISBN, DOI, job number, copyright notice, disclaimer, colophon."
4. If NOT is_first_chunk:
   - Include: "This is a CONTINUATION chunk. SKIP document-wide checks (already done). Focus ONLY on: typography, images, margins, layout issues on these pages."
5. Standard output format and DPI info (reuse from build_user_prompt)
6. Extraction JSON block with note "Pages {chunk_start}-{chunk_end} only"

Keep the existing build_user_prompt function unchanged (used for small documents).
  </action>
  <verify>
Run: python -c "from app.ai.prompts import build_chunk_user_prompt; p = build_chunk_user_prompt('{}', 'publication', 0.9, 'print', 300, 36, 70, False, 3, 2); print('pages 36-70' in p and 'CONTINUATION' in p and 'SKIP document-wide' in p)"
Expected: True
  </verify>
  <done>
build_chunk_user_prompt function exists and produces correct prompts for first and continuation chunks.
Page numbers are actual document pages, not chunk-relative.
First chunk includes document-wide checks instruction, continuation chunks skip them.
  </done>
</task>

</tasks>

<verification>
1. Import chunker module without errors: `python -c "from app.ai.chunker import *"`
2. Import prompts module without errors: `python -c "from app.ai.prompts import *"`
3. Chunk calculation correct for 105 pages: produces 4 chunks with overlaps
4. Chunk prompt for first chunk mentions document-wide checks
5. Chunk prompt for continuation chunk says SKIP document-wide checks
</verification>

<success_criteria>
- DocumentChunker class with needs_chunking() and calculate_chunks() methods
- extract_page_range() creates subset PDFs in memory using PyMuPDF select()
- filter_extraction_for_chunk() filters extraction while preserving actual page numbers
- build_chunk_user_prompt() produces chunk-aware prompts with correct page context
- First vs continuation chunk prompts have different document-wide check instructions
</success_criteria>

<output>
After completion, create `.planning/phases/09-chunked-document-review/09-01-SUMMARY.md`
</output>
